# Architecture Constraints for CIS Evaluation
# A-003 Implementation: Task-specific architectural rules for architecture_score calculation
# Purpose: Transform architecture_score from generic placeholder (0.7) to compliance-based evaluation

# Task: task-001 (Email Validator)
task-001:
  title: "Email Validator"
  constraints:
    no_network_calls:
      description: "Must NOT use socket, dns, urllib, or any network libraries"
      forbidden_imports:
        - "socket"
        - "dns"
        - "urllib"
        - "requests"
        - "httpx"
      penalty: 0.8  # 80% penalty if violated
      rationale: "Sandbox has network_disabled=True; network calls will fail"
    
    regex_only:
      description: "Must use regex pattern matching for validation"
      required_imports:
        - "re"
      penalty: 0.5  # 50% penalty if missing
      rationale: "Task explicitly requires Regex ONLY approach"
    
    no_external_services:
      description: "No email verification APIs or external validation services"
      forbidden_patterns:
        - "api.hunter.io"
        - "zerobounce"
        - "mailgun"
        - "sendgrid"
      penalty: 1.0  # 100% penalty (critical violation)

# Task: task-002 (Rate Limiter)
task-002:
  title: "Rate Limiter"
  constraints:
    no_global_state:
      description: "Must NOT use global variables for storing rate limit state"
      forbidden_patterns:
        - "^\\s*[A-Z_]+\\s*=\\s*\\{.*\\}\\s*$"  # Global dict assignment
      penalty: 0.6  # 60% penalty
      rationale: "Global state violates OOP principles and causes test pollution"
    
    time_module_required:
      description: "Must use time module for timestamp tracking"
      required_imports:
        - "time"
      penalty: 0.4  # 40% penalty if missing
      rationale: "Rate limiting requires accurate time measurement"
    
    no_threading:
      description: "Must NOT use threading or multiprocessing"
      forbidden_imports:
        - "threading"
        - "multiprocessing"
        - "asyncio"
      penalty: 0.5  # 50% penalty
      rationale: "Simple in-memory solution required; threading adds complexity"
    
    data_structure_allowed:
      description: "Should use dict or collections for state management"
      recommended_imports:
        - "collections"
      penalty: 0.0  # No penalty, just recommendation

# Task: task-003 (LRU Cache)
task-003:
  title: "LRU Cache"
  constraints:
    no_http_calls:
      description: "Must NOT make HTTP requests or use web APIs"
      forbidden_imports:
        - "requests"
        - "urllib"
        - "httpx"
        - "http"
      penalty: 1.0  # 100% penalty (critical violation)
      rationale: "Cache should be local data structure, not network-dependent"
    
    no_file_io:
      description: "Must NOT use file system for persistence"
      forbidden_imports:
        - "pickle"
        - "shelve"
        - "json"  # If used for file operations
      forbidden_patterns:
        - "open\\("
        - "with\\s+open"
      penalty: 0.7  # 70% penalty
      rationale: "In-memory cache required; file I/O violates spec"
    
    allowed_data_structures:
      description: "Should use OrderedDict or dict+list for LRU tracking"
      required_imports_any:  # At least one of these
        - "collections.OrderedDict"
        - "collections"
      penalty: 0.3  # 30% penalty if neither used
      rationale: "OrderedDict is standard approach for LRU implementation"
    
    o1_complexity:
      description: "Operations should be O(1) - suggests dict + doubly-linked list or OrderedDict"
      penalty: 0.0  # Checked via logic review, not static analysis

# Task: task-004 (Recursive Fibonacci)
task-004:
  title: "Recursive Fibonacci"
  constraints:
    no_global_variables:
      description: "Must NOT use global variables for memoization cache"
      forbidden_patterns:
        - "^\\s*[a-z_]+\\s*=\\s*\\{.*\\}\\s*$"  # Global dict outside function
        - "^\\s*global\\s+"
      penalty: 0.6  # 60% penalty
      rationale: "Global state violates functional programming principles"
    
    recursion_required:
      description: "Must use recursive function calls (checked separately in analyzer)"
      penalty: 1.0  # 100% penalty if loops detected
      rationale: "Task explicitly requires recursion"
    
    no_loops:
      description: "No for/while loops allowed"
      forbidden_patterns:
        - "\\bfor\\s+"
        - "\\bwhile\\s+"
      penalty: 1.0  # 100% penalty (critical constraint)
      rationale: "Task explicitly forbids loops"
    
    no_forbidden_imports:
      description: "No os, sys, subprocess imports"
      forbidden_imports:
        - "os"
        - "sys"
        - "subprocess"
      penalty: 1.0  # 100% penalty (security violation)
      rationale: "Prevents shell injection or system manipulation"
    
    memoization_allowed:
      description: "functools.lru_cache or manual memoization decorator allowed"
      recommended_imports:
        - "functools"
      penalty: 0.0  # No penalty, optimization is optional

# Constraint Evaluation Notes:
# - Penalties are multiplicative: architecture_score = base_score * (1 - penalty)
# - Multiple violations: Apply max penalty (not cumulative)
# - Static analysis checks: imports, patterns (AST-based)
# - Dynamic checks: Tested via sandbox (e.g., recursion depth, actual behavior)
