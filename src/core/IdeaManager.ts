import { Thought, Segment, Tag } from '../../contracts/entities';
import { StorageAdapter, NewThoughtData, NewSegmentData } from '../../contracts/storageAdapter';
import {
  // generateThoughtId, // Adapter handles thought ID generation
  generateSegmentId,
  isValidThoughtId,
  // isValidSegmentId, // Not currently used, but can be kept for future use
} from '../utils/idUtils'; // Corrected path assuming idUtils is in core/utils
import { logger as defaultLogger } from '../utils/logger'; // Corrected path for logger

/**
 * Manages thought data and operations, providing a centralized interface
 * for data manipulation while abstracting storage details via a StorageAdapter.
 */
export class IdeaManager {
  constructor(private storage: StorageAdapter, private loggerService: typeof defaultLogger = defaultLogger) {}

  /**
   * Returns all thoughts
   */
  async getThoughts(): Promise<Thought[]> {
    this.loggerService.info('IdeaManager: Getting all thoughts.');
    return this.storage.getAllThoughts();
  }

  /**
   * Returns a specific thought by ID
   */
  async getThoughtById(id: string): Promise<Thought | undefined> {
    this.loggerService.info(`IdeaManager: Getting thought by ID: ${id}`);
    return this.storage.getThoughtById(id);
  }

  /**
   * Creates a new thought.
   * ID generation is handled by the storage adapter.
   */
  async addThought(data: NewThoughtData): Promise<Thought> {
    this.loggerService.info('IdeaManager: Adding new thought.', data);
    // ID generation for thoughts is handled by the adapter's createThought method.
    return this.storage.createThought(data);
  }

  /**
   * Updates an existing thought.
   */
  async updateThought(
    thoughtId: string,
    updates: Partial<Omit<Thought, 'thought_bubble_id' | 'created_at' | 'segments' | 'tags'>>
  ): Promise<Thought | undefined> {
    this.loggerService.info(`IdeaManager: Updating thought ID: ${thoughtId}`, updates);
    return this.storage.updateThought(thoughtId, updates);
  }

  /**
   * Removes a thought by ID.
   */
  async deleteThought(thoughtId: string): Promise<boolean> {
    this.loggerService.info(`IdeaManager: Deleting thought ID: ${thoughtId}`);
    return this.storage.deleteThought(thoughtId);
  }

  /**
   * Creates a new segment for a given thought.
   * Segment ID is generated by IdeaManager.
   */
  async addSegment(
    thoughtId: string,
    // The input data for a new segment, excluding IDs and timestamps that IdeaManager or adapter will handle.
    data: Omit<NewSegmentData, 'segment_id' | 'thought_bubble_id' > 
  ): Promise<Segment | undefined> {
    this.loggerService.info(`IdeaManager: Adding segment to thought ID: ${thoughtId}`, data);
    if (!isValidThoughtId(thoughtId)) {
      this.loggerService.error(`IdeaManager: Invalid thought ID format: ${thoughtId}`);
      return undefined;
    }

    // IdeaManager generates the segment_id
    const segmentId = generateSegmentId();
    
    const newSegmentDataWithIds: NewSegmentData = {
      ...data,
      segment_id: segmentId,
      thought_bubble_id: thoughtId, // This is part of NewSegmentData as per previous update
      // Ensure required fields like title, content, content_type are present in 'data'
      // Defaulting for abstraction_level and cluster_id can be done here or in adapter
      abstraction_level: data.abstraction_level || 'Fact',
      cluster_id: data.cluster_id || 'uncategorized_cluster', // or let adapter handle defaults
    };

    return this.storage.createSegment(thoughtId, newSegmentDataWithIds);
  }

  /**
   * Updates an existing segment.
   * The storage adapter's updateSegment method only requires segmentId and updates.
   */
  async updateSegment(
    thoughtId: string, // thoughtId might be useful for context or logging but not directly for adapter
    segmentId: string,
    updates: Partial<Omit<Segment, 'segment_id' | 'thought_bubble_id' | 'created_at'>>
  ): Promise<Segment | undefined> {
    this.loggerService.info(`IdeaManager: Updating segment ID: ${segmentId} for thought ID: ${thoughtId}`, updates);
    // The adapter's updateSegment only needs segmentId and the updates.
    return this.storage.updateSegment(segmentId, updates);
  }

  /**
   * Deletes a segment.
   * The storage adapter's deleteSegment method only requires segmentId.
   */
  async deleteSegment(thoughtId: string, segmentId: string): Promise<boolean> {
    this.loggerService.info(`IdeaManager: Deleting segment ID: ${segmentId} from thought ID: ${thoughtId}`);
    // The adapter's deleteSegment only needs segmentId.
    return this.storage.deleteSegment(segmentId);
  }

  // --- Tagging Methods ---

  async addTagToThought(thoughtId: string, tag: Tag): Promise<Thought | undefined> {
    this.loggerService.info(`IdeaManager: Adding tag "${tag.name}" to thought ID: ${thoughtId}`);
    return this.storage.addTagToThought(thoughtId, tag);
  }

  async removeTagFromThought(thoughtId: string, tagName: string): Promise<Thought | undefined> {
    this.loggerService.info(`IdeaManager: Removing tag "${tagName}" from thought ID: ${thoughtId}`);
    return this.storage.removeTagFromThought(thoughtId, tagName);
  }

  async getThoughtsByTag(tagName: string): Promise<Thought[]> {
    this.loggerService.info(`IdeaManager: Getting thoughts by tag "${tagName}"`);
    return this.storage.getThoughtsByTag(tagName);
  }

  async addTagToSegment(segmentId: string, tag: Tag): Promise<Segment | undefined> {
    this.loggerService.info(`IdeaManager: Adding tag "${tag.name}" to segment ID: ${segmentId}`);
    return this.storage.addTagToSegment(segmentId, tag);
  }

  async removeTagFromSegment(segmentId: string, tagName: string): Promise<Segment | undefined> {
    this.loggerService.info(`IdeaManager: Removing tag "${tagName}" from segment ID: ${segmentId}`);
    return this.storage.removeTagFromSegment(segmentId, tagName);
  }

  async getSegmentsByTag(tagName: string): Promise<Segment[]> {
    this.loggerService.info(`IdeaManager: Getting segments by tag "${tagName}"`);
    return this.storage.getSegmentsByTag(tagName);
  }

  async getAllTags(): Promise<Tag[]> {
    this.loggerService.info('IdeaManager: Getting all tags.');
    return this.storage.getAllTags();
  }
}