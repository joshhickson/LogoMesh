import { Thought, Segment, ContentType, AbstractionLevel, FieldValue, Tag } from './entities';

/**
 * Interface for data needed to create a new thought.
 * Excludes fields that are auto-generated or handled separately.
 */
export interface NewThoughtData {
  title: string;
  description?: string;
  position?: {
    x: number;
    y: number;
  };
  color?: string;
  // Tags will be handled by addTagToThought
}

/**
 * Interface for data needed to create a new segment.
 * Excludes fields that are auto-generated or handled separately by the adapter if not provided.
 * `segment_id` and `thought_bubble_id` are added here to be populated by `IdeaManager` before calling the adapter.
 */
export interface NewSegmentData {
  segment_id: string; // Added: To be generated by IdeaManager
  thought_bubble_id: string; // Added: To be provided by IdeaManager
  title: string;
  content: string;
  content_type: ContentType;
  asset_path?: string; // Added from Segment entity
  fields?: Record<string, FieldValue>; // Use FieldValue for consistency, renamed from segment_fields
  abstraction_level?: AbstractionLevel; // Use AbstractionLevel for consistency
  local_priority?: number; // Added from Segment entity
  cluster_id?: string;
  // Tags will be handled by addTagToSegment
}

/**
 * Defines the contract for storage adapters, providing a consistent API
 * for interacting with the underlying data storage.
 */
export interface StorageAdapter {
  /**
   * Retrieves all thoughts from storage.
   * @returns A promise that resolves to an array of Thought objects.
   */
  getAllThoughts(): Promise<Thought[]>;

  /**
   * Creates a new thought in storage.
   * @param data - The data for the new thought.
   * @returns A promise that resolves to the created Thought object.
   */
  createThought(data: NewThoughtData): Promise<Thought>;

  /**
   * Retrieves a specific thought by its ID.
   * @param thoughtId - The ID of the thought to retrieve.
   * @returns A promise that resolves to the Thought object, or undefined if not found.
   */
  getThoughtById(thoughtId: string): Promise<Thought | undefined>;

  /**
   * Updates an existing thought.
   * @param thoughtId - The ID of the thought to update.
   * @param updates - An object containing the fields to update.
   *                  Excludes 'thought_bubble_id', 'created_at', 'segments', and 'tags'.
   * @returns A promise that resolves to the updated Thought object, or undefined if not found.
   */
  updateThought(thoughtId: string, updates: Partial<Omit<Thought, 'thought_bubble_id' | 'created_at' | 'segments' | 'tags'>>): Promise<Thought | undefined>;

  /**
   * Deletes a thought from storage.
   * @param thoughtId - The ID of the thought to delete.
   * @returns A promise that resolves to true if deletion was successful, false otherwise.
   */
  deleteThought(thoughtId: string): Promise<boolean>;

  /**
   * Retrieves all segments associated with a specific thought.
   * @param thoughtId - The ID of the thought.
   * @returns A promise that resolves to an array of Segment objects.
   */
  getSegmentsForThought(thoughtId: string): Promise<Segment[]>;

  /**
   * Creates a new segment and associates it with a thought.
   * @param thoughtId - The ID of the parent thought.
   * @param data - The data for the new segment.
   * @returns A promise that resolves to the created Segment object.
   */
  createSegment(thoughtId: string, data: NewSegmentData): Promise<Segment>;

  /**
   * Retrieves a specific segment by its ID.
   * @param segmentId - The ID of the segment to retrieve.
   * @returns A promise that resolves to the Segment object, or undefined if not found.
   */
  getSegmentById(segmentId: string): Promise<Segment | undefined>;

  /**
   * Updates an existing segment.
   * @param segmentId - The ID of the segment to update.
   * @param updates - An object containing the fields to update.
   *                  Excludes 'segment_id', 'thought_bubble_id', and 'created_at'.
   * @returns A promise that resolves to the updated Segment object, or undefined if not found.
   */
  updateSegment(segmentId: string, updates: Partial<Omit<Segment, 'segment_id' | 'thought_bubble_id' | 'created_at'>>): Promise<Segment | undefined>;

  /**
   * Deletes a segment from storage.
   * @param segmentId - The ID of the segment to delete.
   * @returns A promise that resolves to true if deletion was successful, false otherwise.
   */
  deleteSegment(segmentId: string): Promise<boolean>;

  /**
   * Adds a tag to a thought. If the tag already exists on the thought, it should not be duplicated.
   * The `Tag` object (name, color) should be created if it doesn't exist in a central tag list.
   * @param thoughtId - The ID of the thought.
   * @param tag - The tag object to add.
   * @returns A promise that resolves to the updated Thought object, or undefined if the thought is not found.
   */
  addTagToThought(thoughtId: string, tag: Tag): Promise<Thought | undefined>;

  /**
   * Removes a tag from a thought.
   * @param thoughtId - The ID of the thought.
   * @param tagName - The name of the tag to remove.
   * @returns A promise that resolves to the updated Thought object, or undefined if the thought is not found.
   */
  removeTagFromThought(thoughtId: string, tagName: string): Promise<Thought | undefined>;

  /**
   * Retrieves all thoughts associated with a specific tag.
   * @param tagName - The name of the tag.
   * @returns A promise that resolves to an array of Thought objects.
   */
  getThoughtsByTag(tagName: string): Promise<Thought[]>;

  /**
   * Adds a tag to a segment. If the tag already exists on the segment, it should not be duplicated.
   * The `Tag` object (name, color) should be created if it doesn't exist in a central tag list.
   * @param segmentId - The ID of the segment.
   * @param tag - The tag object to add.
   * @returns A promise that resolves to the updated Segment object, or undefined if the segment is not found.
   */
  addTagToSegment(segmentId: string, tag: Tag): Promise<Segment | undefined>;

  /**
   * Removes a tag from a segment.
   * @param segmentId - The ID of the segment.
   * @param tagName - The name of the tag to remove.
   * @returns A promise that resolves to the updated Segment object, or undefined if the segment is not found.
   */
  removeTagFromSegment(segmentId: string, tagName: string): Promise<Segment | undefined>;

  /**
   * Retrieves all segments associated with a specific tag.
   * @param tagName - The name of the tag.
   * @returns A promise that resolves to an array of Segment objects.
   */
  getSegmentsByTag(tagName: string): Promise<Segment[]>;
  
  /**
   * Updates the custom fields of a segment.
   * This should replace all existing fields with the provided set.
   * @param segmentId The ID of the segment to update.
   * @param fields A record of field names to their values.
   * @returns A promise that resolves to the updated Segment object, or undefined if not found.
   */
  updateSegmentFields(segmentId: string, fields: Record<string, FieldValue>): Promise<Segment | undefined>;

  /**
   * Retrieves all unique tags available in the system.
   * @returns A promise that resolves to an array of Tag objects.
   */
  getAllTags(): Promise<Tag[]>;

  /**
   * Retrieves a specific tag by its name.
   * @param tagName The name of the tag to retrieve.
   * @returns A promise that resolves to the Tag object, or undefined if not found.
   */
  getTagByName(tagName: string): Promise<Tag | undefined>;

  /**
   * Updates a tag. This is useful for changing a tag's color.
   * @param tagName The current name of the tag to update.
   * @param newTagData The new data for the tag (e.g., new name, new color).
   * @returns A promise that resolves to the updated Tag object, or undefined if the tag is not found.
   */
  updateTag(tagName: string, newTagData: Partial<Tag>): Promise<Tag | undefined>;

  /**
   * Deletes a tag from the central list of tags and removes it from all associated thoughts and segments.
   * @param tagName The name of the tag to delete.
   * @returns A promise that resolves to true if deletion was successful, false otherwise.
   */
  deleteTag(tagName: string): Promise<boolean>;
}
