2. Backend API Server & SQLite Database Foundation:
* Framework Outcome: A runnable Node.js/Express.js backend server and an initialized SQLite database with the correct schema.
* Detailed Actions (for AI Agent):
a.  Set Up Backend Server Project (server/ directory):
* Create a new top-level directory named server/.
* Initialize a Node.js project within server/ (npm init -y or equivalent).
* Install dependencies: express, cors, sqlite3.
* Set up for TypeScript: install typescript, @types/express, @types/cors, @types/node, ts-node, nodemon as dev dependencies. Create server/tsconfig.json (module: commonjs, target: es2020, outDir: ./dist, rootDir: ./src, esModuleInterop: true, resolveJsonModule: true). Create server/src/ for source files. Add build/start/dev scripts to server/package.json.
* Create server/src/index.ts as the main server entry point.
* Implement Express app setup: use cors(), express.json().
* Add a GET /api/v1/health route (use process.env.API_BASE_PATH) returning { status: "healthy", timestamp: new Date().toISOString() }.
* Start server on process.env.PORT || 3001.
* Implement Bootstrap Logging: At startup, log (using @core/utils/logger.ts via relative path or updated alias) the perceived environment, port, DB_PATH (from process.env), and PLUGIN_DIR.
* Verification: Express server starts, health check works, bootstrap logs appear.
b.  Define and Initialize SQLite Database Schema:
* (Prerequisite Check): Ensure the "Phase 1 SQLite Schema" section in docs/Merged Milestone-Based Development Plan v2.0.md is complete and accurate, detailing all tables, columns, types, keys, and constraints for thoughts, segments, tags, thought_tags, segment_tags, segment_fields, segment_neighbors, segment_related_context, segment_llm_history.
* In core/db/schema.sql (created in Phase 0), populate with CREATE TABLE statements from the verified plan.
* In core/db/initDb.ts (created in Phase 0), implement initializeDatabase():
* Use sqlite3. Connect to process.env.DB_PATH (defaulting to server/data/logomesh.sqlite3 if run from server dir, or core/db/logomesh.sqlite3 if run from core dir â€“ path needs to be robust). Create the data directory if it doesn't exist.
* Read core/db/schema.sql. Execute CREATE TABLE IF NOT EXISTS ... for all tables.
* Use logger from core/utils/logger.ts.
* Modify server/src/index.ts startup sequence to call await initializeDatabase() before starting the Express listener, ensuring the DB is ready. Handle potential errors during DB initialization.
* Verification: Server startup initializes the DB. logomesh.sqlite3 is created at the configured DB_PATH with the correct schema.
c.  Integrate LLM Execution Layer Stubs:
* Create core/llm/OllamaExecutor.ts implementing LLMExecutor from contracts/llmExecutor.ts. executePrompt returns a mocked response (e.g., Promise.resolve(\Mocked response for: ${prompt}`)). supportsStreamingisfalse. * Create core/llm/LLMTaskRunner.tsclass withconstructor(private executor: LLMExecutor)andasync run(prompt: string, metadata?: Record<string, any>): Promise<string>method that callsthis.executor.executePromptand logs vialogLLMInteractionfromcore/logger/llmAuditLogger.ts. Include the runPromptWithStreaming?stub. * Createcore/llm/utils/mermaidAuditor.tswith stubisValidMermaidfunction. * Createserver/src/routes/llmRoutes.ts: POST /api/v1/llm/promptendpoint usingLLMTaskRunnerwith an instance ofMockLLMExecutor(fromcore/llm/MockLLMExecutor.tscreated in Phase 0) or the newOllamaExecutorstub. Mount this router inserver/src/index.ts. * **Crucial VTC Preparation:** Ensure LLMExecutorimplementations (includingMockLLMExecutorandOllamaExecutor.tsstub) **do not hardcode assumptions about embedding formats or types**. They should be designed to receive context/prompts that *could* originate from a VTC-translated source in future phases. * *Verification:*POSTto/api/v1/llm/promptreturns mock response and logs viallmAuditLogger`.
d.  Define VTC & Embedding Interfaces (Crucial for Phase 2 readiness):
* Purpose: To establish the foundational TypeScript interfaces for the Vector Translation Core (VTC), ensuring that all embedding interactions within LogoMesh are abstracted and that the system is ready for multi-model and multi-modal embedding translation in Phase 2. This also includes defining an "Ephemeral Embedding Policy" to avoid persistent storage of raw embeddings.
* Create new directory: contracts/embeddings/.
* Create contracts/embeddings/embeddingInterface.ts.
typescript // contracts/embeddings/embeddingInterface.ts /** * Abstract interface for all embedding interactions to ensure model-agnostic handling. * Components interacting with embeddings (e.g., ShellNode, EchoMesh) should use this. */ export interface EmbeddingInterface { toVector(input: any): Promise<number[]>; fromVector(vector: number[]): Promise<any>; getModelName(): string; getDimension(): number; } 
* Create contracts/embeddings/ulsConfig.ts.
typescript // contracts/embeddings/ulsConfig.ts /** * Defines configuration for the Universal Latent Space (ULS) for VTC. * Its parameters (e.g., dimension) will be crucial for VTC training/inference. */ export interface ULSConfig { dimension: number; // E.g., 512, 768, 1024 (from ULS_DIMENSION env var) // Add other ULS specific configs as needed for VTC training/inference } 
* Create contracts/embeddings/adapterRegistry.ts.
```typescript
// contracts/embeddings/adapterRegistry.ts
import { EmbeddingInterface } from './embeddingInterface';
/**
* Interface for registering and retrieving different embedding adapters for VTC.
* This allows dynamic loading of model-specific input/output adapters.
*/
export interface AdapterRegistry {
registerAdapter(modelName: string, inputAdapter: EmbeddingInterface, outputAdapter: EmbeddingInterface): void;
getInputAdapter(modelName: string): EmbeddingInterface | undefined;
getOutputAdapter(modelName: string): EmbeddingInterface | undefined;
}
```
* Ephemeral Embedding Policy Enforcement:
* Review any existing (or soon-to-be implemented) code paths in src/ or core/ that might handle or store raw embedding vectors (e.g., in Thought or Segment DTOs, or temporary memory).
* Ensure that any raw embedding vectors are treated as ephemeral and not persistently stored in the database or localStorage. If they must be stored temporarily, implement a TTL (time-to-live) mechanism or clear them after use. This prepares for the VTC's secure latent vector substitution in Phase 2.
* (Note for AI Agent: For Segment's embedding_vector? field, it should be understood as a conceptual placeholder for future processed/translated embeddings or for use with a dedicated local embedding service that runs after VTC has potentially translated them.)
* Verification: New files are created in contracts/embeddings/ with the specified interfaces. Code practices avoid persistent raw embedding storage.