4. Implement Backend API Endpoints for Core Entities:
* Framework Outcome: Backend API exposes RESTful CRUD for Thoughts and Segments.
* Detailed Actions (for AI Agent):
a.  Instantiate Core Services in Server (server/src/index.ts):
* Create instances: const sqliteAdapter = new SQLiteStorageAdapter(process.env.DB_PATH || './data/logomesh.sqlite3');
* const ideaManager = new IdeaManager(sqliteAdapter, logger);
* Make ideaManager (and other core services like LLMTaskRunner, PortabilityService once created) available to route handlers (e.g., via Express app locals, or by passing them when setting up routes).
* Verification: Server instantiates services with SQLiteStorageAdapter.
b.  Create API Routes for Thoughts (server/src/routes/thoughtRoutes.ts):
* Implement Express router for /api/v1/thoughts.
* Endpoints: GET /, POST /, GET /:thoughtId, PUT /:thoughtId, DELETE /:thoughtId.
* Handlers call respective ideaManager methods. Implement request body validation, error handling (returning appropriate HTTP statuses), and logging.
* Mount in server/src/index.ts.
* Verification: Endpoints function correctly; data persists in SQLite.
c.  Create API Routes for Segments (e.g., nested under thoughts):
* In thoughtRoutes.ts or new segmentRoutes.ts, implement:
* POST /api/v1/thoughts/:thoughtId/segments
* PUT /api/v1/thoughts/:thoughtId/segments/:segmentId
* DELETE /api/v1/thoughts/:thoughtId/segments/:segmentId
* Similar logic, validation, error handling.
* Verification: Segment CRUD via API works.
5. Refactor React Frontend to Consume Backend API:
* Demo Implementation Outcome: React app uses HTTP requests for all data operations.
* Detailed Actions (for AI Agent):
a.  Create API Service Layer (src/services/apiService.ts):
* Module to encapsulate Workspace/axios calls to process.env.REACT_APP_API_URL || 'http://localhost:3001/api/v1'.
* Export async functions for all CRUD operations (e.g., WorkspaceThoughts(), createThoughtApi(data: NewThoughtData)). Basic error handling (check response.ok).
* Verification: apiService.ts created with necessary functions.
b.  Refactor src/App.jsx:
* Remove IdeaManager direct usage. Import and use apiService.
* useEffect on mount calls apiService.fetchThoughts().
* createThought calls apiService.createThoughtApi(), then re-fetches all thoughts (initial strategy).
* refreshThoughts callback (for children) calls apiService.fetchThoughts().
* Verification: App.jsx loads and modifies data via API.
c.  Refactor Child Components (e.g., ThoughtDetailPanel.jsx, Canvas.jsx):
* Remove ideaManager prop. Use callbacks from App.jsx that invoke apiService methods, followed by refreshThoughts.
* Verification: UI interactions for data modification use the API. Data persists across reloads.
6. Refine Graph Visualization (Cytoscape.js):
* Demo Implementation Outcome: Graph canvas visualizes Thoughts as compound parents with Segment children, using fcose layout.
* Detailed Actions (for AI Agent):
a.  Modify src/components/Canvas.jsx for Compound Nodes:
* Refactor elements generation: Segment nodes' data object must include parent: thought.thought_bubble_id.
* Remove direct Thought-to-Segment edges; prioritize compound representation.
* Verification: Segments appear nested in thought bubbles.
b.  Integrate and Configure cytoscape-fcose Layout:
* Ensure cytoscape.use(fcose); is called. Set layout: { name: 'fcose', ... }.
* Configure fcose parameters for clarity (refer to ARCHITECTURE.MD v2.8 for goals).
* Verification: Graph uses fcose; compound nodes are clearly arranged.
c.  Handle Node Position Updates:
* dragfree event saves positions of compound Thought nodes via apiService.updateThoughtApi(...).
* Verification: Dragging thoughts updates position via API.
7. Scaffold Cognitive Context Engine (CCE) Foundations:
* Framework Outcome: Initial interfaces and conceptual plans for the CCE are in place, with the ThoughtExportProvider being enhanced for semantic compression.
* Detailed Actions (for AI Agent):
a.  Create CCE Placeholder Module:
* Create directory core/context/.
* Create core/context/cognitiveContextEngine.ts as a planned stub. Its purpose will be to act as the "semantic lens" for context generation in future phases.
* ```typescript
// core/context/cognitiveContextEngine.ts
/**
* @module CognitiveContextEngine
* @description Planned for Phase 2+. Responsible for dynamically assembling and refining contextually relevant information from the knowledge graph.
* Acts as a semantic lens and compression engine for LLM interactions.
* (Stub for Phase 1)
/
export class CognitiveContextEngine {
constructor(/ Dependencies like IdeaManager, MeshGraphEngine, VTC */) {
// Logic planned for Phase 2+
}
// Planned method stubs for context generation:
async generateContextForLLM(thoughtId: string, query: string, options?: any): Promise<any> {
// This method will leverage ThoughtExportProvider and potentially VTC
console.log([CCE Stub] Generating context for thought ${thoughtId} with query: ${query});
return Promise.resolve("Mock context based on thought title.");
}
// Other planned methods: getRelatedContext, compressContext, etc.
}
```
* (Note for AI Agent): For Phase 1, the CCE itself is a conceptual placeholder. The focus is on its foundational dependencies.)
b.  Enhance ThoughtExportProvider (contracts/thoughtExportProvider.ts and core/services/portabilityService.ts):
* Review and ensure the ThoughtExportProvider interface in contracts/thoughtExportProvider.ts (or equivalent interface within IdeaManager or PortabilityService if not a standalone interface yet) can support options related to semantic compression, such as abstractionLevelFilter, localPriorityThreshold, clusterIdFilter, maxDepth (simulated).
* Within core/services/portabilityService.ts (or wherever exportData lives), ensure the exportData method's implementation can conceptually filter and organize data based on these semantic compression options, even if the actual "compression" logic is rudimentary in Phase 1 (e.g., just basic filtering before full semantic summarization).
* The MeshGraphEngine (core/services/meshGraphEngine.ts) should also have its stubbed methods (e.g., getRelatedThoughts, clusterThoughtsByTag) enhanced to support these semantic filtering/traversal concepts, which the CCE will rely on later.
* Verification: CognitiveContextEngine.ts stub exists. ThoughtExportProvider interface and initial implementation (in PortabilityService or IdeaManager) can accept and rudimentary apply semantic compression options. MeshGraphEngine stubs conceptually support semantic traversal for CCE.