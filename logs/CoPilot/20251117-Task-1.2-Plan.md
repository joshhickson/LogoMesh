pnpm --filter @logomesh/workers run verify:ivm# Task 1.2 Plan: Build Secure Sandbox for `testingDebtAnalyzer`

**Date:** 2025-11-17
**Author:** GitHub Copilot (Executive Developer)
**Reference:** `logs/technical/20251113_RECOVERY_PLAN.md`

## 1. Objective

This document outlines the detailed plan to complete **Task 1.2**, which involves integrating the `isolated-vm` library to create a secure, sandboxed environment for the `testingDebtAnalyzer`. The goal is to replace the current, potentially insecure test execution method with one that prevents arbitrary file system access and enforces strict execution timeouts, as per the acceptance criteria.

## 2. Acceptance Criteria

1.  The sandbox must prevent any file system access outside of a designated temporary directory.
2.  The sandbox must enforce a non-negotiable execution timeout on the test code.
3.  The `testingDebtAnalyzer` must successfully capture a `pass` or `fail` result from the sandboxed environment.
4.  The implementation must be robust and production-ready.

## 3. Detailed Execution Plan

This task will be executed in a series of sequential, verifiable steps.

### Step 1: Environment and Dependency Verification

**Goal:** Confirm that the `isolated-vm` library, a known previous blocker, is correctly installed and functional in the current development environment.

*   **Action 1.1:** Review the root `package.json` and relevant workspace `package.json` files to confirm `isolated-vm` is listed as a dependency.
*   **Action 1.2:** Create a temporary test file (`tmp-iso-verify.ts`) in the `packages/testing-debt-analyzer` directory (or other appropriate location).
*   **Action 1.3:** In this file, write a minimal script that imports `isolated-vm`, creates an `Isolate`, and executes a simple `console.log('Hello from isolate')`.
*   **Action 1.4:** Execute this script using `ts-node` or a similar runner to confirm it runs without build-time or run-time errors.
*   **Action 1.5:** Delete the temporary file upon successful verification.

This step ensures the foundational native dependency is stable before any logic is built upon it.

### Step 2: Locate and Analyze `testingDebtAnalyzer`

**Goal:** Understand the existing implementation for test execution to identify the exact code that needs to be replaced.

*   **Action 2.1:** Use workspace search to locate the `testingDebtAnalyzer.ts` file. Based on the project structure, it is likely within `packages/`.
*   **Action 2.2:** Read the contents of the file, paying close attention to how it currently receives and executes test code. Identify the function or method responsible for running the test (e.g., looking for `eval`, `new Function()`, or `child_process.exec`).
*   **Action 2.3:** Document the current input (the test code string) and the expected output (the test result).

### Step 3: Implement the `isolated-vm` Sandbox

**Goal:** Replace the insecure execution method with a secure sandbox using `isolated-vm`.

*   **Action 3.1:** In `testingDebtAnalyzer.ts`, import the `isolated-vm` library.
*   **Action 3.2:** Refactor the test execution method. The new logic will:
    1.  Instantiate a new `Isolate({ memoryLimit: ... })`. A reasonable memory limit (e.g., 128MB) will be set as a safeguard.
    2.  Create a new `Context` within the isolate.
    3.  Define a `Jail` for the context's global object to restrict access.
*   **Action 3.3 (Result Capture):** Use `jail.set()` to inject a synchronous callback function (e.g., `reportResult`) into the sandboxed global scope. The test code provided by the "Purple Agent" will be expected to call this function with its result (e.g., `reportResult('pass')`).
*   **Action 3.4 (Execution):**
    1.  Compile the test code string using `isolate.compileScript()`.
    2.  Run the compiled script within the context using `script.run(context, { timeout: ... })`. A strict timeout (e.g., 5000ms) will be passed here to satisfy the acceptance criteria.
    3.  Wrap the execution in a `try...catch` block to handle timeouts and other execution errors, which will be treated as test failures.

### Step 4: Implement Secure, Temporary File System Access

**Goal:** Provide a controlled, temporary directory for the sandboxed code to use, preventing access to the host file system.

*   **Action 4.1:** Use the Node.js built-in `fs/promises` and `path` modules to manage file system operations.
*   **Action 4.2:** Before executing the test, create a unique temporary directory using `fs.mkdtemp()`.
*   **Action 4.3:** Create a "jailed" `fs` object that exposes a limited set of `fs` functions (e.g., `readFile`, `writeFile`). Each of these functions will be wrapped in a security layer that:
    1.  Takes a relative path from the sandboxed code.
    2.  Resolves the absolute path using `path.join(tempDir, relativePath)`.
    3.  **Crucially, verifies that the resolved absolute path is still within the created temporary directory.** Any attempt to access a path outside this directory (e.g., using `../`) will throw an error.
*   **Action 4.4:** Inject this jailed `fs` object into the sandbox using `jail.set('fs', jailedFs)`.
*   **Action 4.5:** Implement a `finally` block to ensure the temporary directory and its contents are recursively deleted after the test execution, regardless of the outcome.

### Step 5: Testing and Validation

**Goal:** Write unit and integration tests to prove the implementation meets all acceptance criteria.

*   **Action 5.1:** Create a new test file, `testingDebtAnalyzer.sandbox.test.ts`.
*   **Action 5.2:** Write a test case for the "happy path" where valid test code runs, reports a `pass` result, and is correctly captured.
*   **Action 5.3:** Write a test case for a script that enters an infinite loop to verify the `timeout` option correctly terminates execution and the test is marked as `fail`.
*   **Action 5.4:** Write a test case where the sandboxed code attempts to access a file outside its temporary directory (e.g., `/etc/passwd`, `c:\\windows\\system32`, or a file in the project root). Verify that the attempt is blocked and the test fails.
*   **Action 5.5:** Write a test case where the sandboxed code attempts to access a Node.js module that was not explicitly provided (e.g., `child_process`). Verify the import fails.

By following this plan, Task 1.2 will be completed in a structured, verifiable, and secure manner.
